#CallingConventions

**스택을 이용하여 인자(argument)를 전달할 때 스택에 인자를 어떤 순서로 넣을 것이며 전달된 인자를 어느 곳에서 해제할 것인가를 결정하는 규약.**

##__stdcall (standard call)

	파라미터 전달은 오른쪽에서 왼쪽 방향으로 스택에 저장.

	프로시저를 부르기 전에 스택에 파라미터를 쌓아놓고 그 프로시저를 부르기만 하면 그 함수가 리턴된 후에는 그 프로시저의 스택 포인터가 이전 상태로 복원되어있으므로 복귀된 후에 호출한 프로시저에 대하여 신경쓸 필요가 없음.

	함수 내부에서 스택을 정리한다. 함수 내부에서 인자를 바로 ret 하면서 정리하기 때문에 stdcall이 cdecl 보다 빠르고 바이너리 사이즈가 좀 더 작다. 
	cdecl은 ret 후 인자를 정리하는 별도의 코드가 필요하다.

	함수 독립성이 뛰어나므로 DLL을 만들 때는 반드시 stdcall로 선언해야 한다.
	함수 이름 앞에 _가 붙으며 뒤에 @가 붙은 후 인수 목록의 바이트 수가 붙는다. 

##__cdecl (C declaration)

	파라미터 전달은 오른쪽에서 왼쪽 방향으로 스택에 저장.

	(유일하게 cdecl만) 함수를 호출한 쪽에서 스택을 정리한다. [main-> add함수 호출 후 main 함수에서 스택을 정리]
	인자를 정리하려면 인자가 몇 개인지 알아야 하는데 따라서 인자가 불분명한 가변인자는 cdecl에서만 지원한다.
	C와 가변인자를 사용하는 C++ 함수의 기본 호출 규약. 함수 이름 앞에 _가 붙는다.

	기본 호출 규약에 대한 VC++ 컴파일러 옵션 - /Gz (stdcall), /Gr (fastcall), /Gd (cdecl)



##__fastcall

	처음 두 개까지의 DWORD 파라미터는 스택을 사용하지 않고, ECX와 EDX레지스터를 사용함

	그 이상의 파라미터에 대해서만 오른쪽에서 왼쪽으로 스택에 저장.

	스택 제거는 stdcall과 동일하다.

	인텔 CPU에서만 적용되고 볼랜드 컴파일러의 기본 호출 규약이다.

	<장점>

	좀 더 빠른 함수 호출이 가능하다.

	<단점>

	ECX, EDX 레지스터를 관리하는 추가적인 오버헤드가 필요한 경우가 이다.
	ECX, EDX에 중요한 값이 저장되어 있다면 백업해 놓아야 한다.

##thiscall

	주로 가변인자를 사용하지 않는 c++의 클래스에서 사용되는 방법이다. 현재 객체의 포인터를 ecx에 전달하고, 현재 자신이
	어떤 객체를 이용하고 있는지 구분해줄 값이 필요하기 때문에 c++에서는 this포인터로 사용.
	즉, ecx로 전달되는 값이 this포인터가 된다.

	컴파일시 가변인자인 경우 cdecl로 변경된다.

	인자 전달이나 스택 처리 방법은 stdcall과 동일하다.



□ ECX(Extended Counter Register)

반복 명령어 사용시 반복 카운터로 사용된다. ECX 레지스터에 반복할 횟수를 지정해 놓고 반복 작업을 수행하게 된다.


□ EDX(Extended Data Register)

EAX와 같이 쓰이며 부호 확장 명령 등에 쓰인다