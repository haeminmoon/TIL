#Process and Thread

1. 멀티 프로세스의 문제점
- 두 개의 프로세스는 완전히 독립된 두 개의 프로그램 실행을 위해서 사용되기 때문에 컨텍스트 스위칭(프로세스의 상태 정보를 저장하고 복원하는 일련의 과정)으로 인한 성능 저하가 발생한다.
- 쓰레드는 하나의 프로그램 내에서 여러 개의 실행 흐름을 두기 위한 모델이다.
- 쓰레드는 프로세스처럼 완벽히 독립적인 구조가 아니다. 쓰레드들 사이에는 공유하는 요소가 있다.
- 쓰레드는 이 공유하는 요소로 인해 컨텍스트 스위칭에 걸리는 시간이 프로세스보다 짧다.

2. 프로세스와 쓰레드의 차이점 

- 프로세스는 완벽히 독립적이기 때문에 메모리 영역(Code, Data, Heap, Stack)을 다른 프로세스와 공유하지 않는다.
- 쓰레드는 해당 쓰레드를 위한 스택을 생성할 뿐 그 이외의 Code, Data, Heap영역을 공유한다.
​
1) 스택을 독립적으로 할당하는 이유
- 스택은 함수 호출 시 전달되는 인자, 되돌아갈 주소값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간이다.
- 따라서 스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능하다는 것이고, 이는 독립적인 실행 흐름이 추가되는 것이다.
- 결과적으로 실행 흐름의 추가를 위한 최소 조건이 독립된 스택을 제공하는 것이다.
​
2) 코드 영역을 공유
- 프로세스는 독립적인 구조이기 때문에 다른 프로세스의 Code영역에 있는 함수를 호출할 수 없다.
- 쓰레드는 Code영역을 공유하기 때문에 두 개 이상의 쓰레드가 자신이 포함된 프로세스의 Code영역에 있는 함수를 호출할 수 있다.
​
3) 데이터 영역과 힙 영역을 공유
- 전역 변수와 동적 할당된 메모리 공간을 공유할 수 있고, 이를 통해 쓰레드 간 통신을 할 수 있다.
- 대신 동시에 메모리에 접근하기 때문에 주의해야 한다.


3. 쓰레드가 프로세스보다 컨텍스트 스위칭이 빠른 이유

-쓰레드가 프로세스보다 컨텍스트 스위칭이 빠른 이유는 메모리 영역을 공유하기 때문이다. 실제로 공유되는 데이터가 있고 아닌 데이터가 있다.
​
1) sp(Stack Pointer), fp(Frame Pointer), pc(Program Counter) 레지스터
-pc는 실행해야 할 명령어의 위치를 가리키는 레지스터이다.
-쓰레드별로 main함수를 독립적으로 가지고 있고, 함수 호출도 독립적으로 진행되기 때문에 쓰레드별로 현재 pc값은 달라야 한다. 따라서 pc는 공유되지 않는다.
​-쓰레드는 독립적인 스택을 가지기 때문에 스택의 정보를 담고 있는 sp와 fp는 공유되지 않는다.
​
2) 범용적으로 사용가능한 레지스터
-시스템을 어떻게 디자인 하느냐에 따라 달라지는 것이기 때문에 일반적으로 공유된다고 할 수 없다.
​
3) 캐시메모리

-캐시 메모리는 CPU에서 한번 이상 읽어 들인 메인 메모리의 데이터를 저장하고 있다가 CPU가 다시 그 메모리에 저장된 데이터를 요구할 때 메인 메모리를 통하지 않고 바로 값을 전달하는 용도로 사용된다.
-프로세스 사이에서 공유하는 메모리가 하나도 없기 때문에 컨텍스트 스위칭이 발생하면 캐쉬에 있는 모든 데이터를 모두 리셋하고 다시 캐쉬 정보를 불러와야 한다.
-쓰레드는 캐쉬 정보를 비울 필요가 없기 때문에 프로세스와 쓰레드의 컨텍스트 스위칭 속도의 차이는 이때 발생한다.

4. Windows에서의 프로세스와 쓰레드

-Windows 입장에서 프로세스는 쓰레드를 담는 상자에 지나지 않는다.
-또한 Windows에서 프로세스는 상태(Running, Ready, Blocked)을 지니지 않는다. 상태를 지니는 것은 스레드이다.
-스케줄러가 실행의 단위로 선택하는 것도 프로세스가 아닌 스레드이다.
-프로세스 컨텍스트 스위칭 역시 실제로 오버헤드가 발생하는 부분은 서로 다른 프로세스에 포함된 스레드 간의 컨텍스트 스위칭시 발생한다. 


1. 프로세스는 독립적으로 실행되며 자신만의 고유공간과 자원을 할당 받아 사용한다.
쓰레드는 한 프로세스 내에서 동작되는 여러 실행흐름 으로 프로세스 내 주소 공간이나 자원들을 대부분 공유하면서 실행된다.

2. 프로세스는 부모 프로세스의 데이터 세그먼트의 자체 복사폰을 가지고 있다.
스레드는 그 프로세스의 데이터 세그먼트에 직접 엑세스 가능하다.

3. 프로세스는 형제 프로세스와 통신하기 위해서 반스디 프로세스간 통신을 사용해야 한다.
스레드는 프로세스내 다른 스레드와 직접 통신 할 수 있다.


4. 프로세스는 상당한 오버헤드가 있다.
스레드는 오버헤드가 거의 없다.
* 오버헤드(overhead)는 어떤 처리를 하기 위해 들어가는 간접적인 처리 시간 · 메모리 등을 말한다. 

5. 새로운 프로세스는 부모 프로세스의 복제를 필요로 한다.
새로운 스레드를 쉽게 만들 수 있다.

6. 프로세스는 자식 프로세스에 대한 제어를 행사 할 수 있다.
스레드는 동일한 프로세스의 스레드를 제어 할 수 있다.

7. 부모 프로세스에 대한 변경은 자식 프로세스에 영향을 주지 않는다.
메인 쓰레드의 변경(취소,우선순위변경 등) 은 프로세스내 다른 스레드의 행동에 영향을 미칠 수 있다.


**스레드의 장점**

- 시스템의 throughput이 향상된다.
- 시스템의 자원 소모가 줄어든다.
- 프로그램 응답 시간이 단축된다.
- 프로세스 간 통신 방법에 비해 스레드 간의 통신 방법이 훨씬 간단하다.

**스레드의 단점**
- 프로그램 디버깅이 어렵다.
- 여러개의 스레드를 이용하는 프로그램을 작성하는 경우에는 주의 깊게 설계해야 한다.

- 스레드간 통신시에 데이터를 주고받는 방법은 메모리 공간을 공유하므로 데이터 세그먼트, 즉 전역 변수를 이용하여 구현한다. 
- 그런데 전역변수를 여러 스레드가 함께 사용하려면 문제가 발생한다.  따라서 스레드 간에 통신을할 경우에는 충돌 문제가 발생하지 않도록 동기화 문제를 해결해야 한다.