# SQL튜닝 (3)

## Join

- 오라클 조인보다는 안시조인을 사용하자. 그 이유는 쿼리가 어떤 일을 수행해서 데이터를 얻어내는지 쉽게 읽을 수 있기 때문에. ( 성능상의 차이는 없음, 하지만 아우터 조인시 양쪽에 (+)하는 것은 오라클 조인에서는 불가능 하다.)

- 테이블을 설계할 때는 항상 제약조건들을 잘 이용하자.


- 테이블 조인 할 때 절대로 m:m 조인은 하면 안된다. (에러는 아니지만 이슈가 발생한다.)


## 조인 ( Nested join, Hash join, Sort merge join )

- 선행 테이블(Outer Table) 접근하여 후보 행을 선택하고, 조인 조건에 만족하는 후행 테이블(Inner Table)을
반복적으로 접근하여 조인 결과 생성
- Inner Table의 조인 컬럼에 인덱스가 존재하지 않으면 "FULL TABLE SCAN"이 사용되므로 인덱스 필요
- FIRST_ROWS 상황에 최적화 가능하며, 많은 양의 조인 결과 생성 시 반복 접근으로 인한 성능 저하 발생

SELECT /*+ leading(d) use_nl(e) */ d.deptno, d.dname, e.empno, e.ename, e.sal
FROM cp_dept d, cp_emp e
WHERE d.deptno = e.deptno ;

이렇게 하면 emp테이블이 4번이나 풀 스캔 됨.


이때 /*+ leading(d) use_nl(e) */ 이처럼 강제로 중첩 조인을 힌트로 넣지 않으면 헤쉬조인이 발생하게 된다.

헤쉬 조인은 메모리를 사용하는 반면 중첩 조인은 루핑을 돌면서 풀스캔을 더 하게됨.

* 중첩 조인은 추가적인 메모리를 사용하지 않기 때문에 온라인에 최적화 되어 있다. 예를 들어.. 게시판 처럼 50개~100개 씩 보여주는 것... 페이지를 넘기면 그다음걸 보여주는 것...

* 헤쉬 조인은 메모리를 사용하며, 공간이 충분하지 않으면 디스크까지 내려갈 수도 있긴 하다. 내부적으론 헤쉬 함수를 사용함.
헤쉬 함수의 리턴값이 같은 것들끼리 파티션으로 묶어내는 것임. 


즉, 중첩 조인은 중첩행이 적은 쪽에 인덱스가 필요하다.

nested vs hash
상황에 따라서 틀리다. ( 문장이 어디서 실행 되느냐)

/*+ first rows, all rows */ 이런걸로 조인 테스를 해봐도 ㄱㅊ



* hash join 은 이퀴조인일 때만 가능한데, 이게 불가능한 상황에서는 sort merge join 을 수행한다. (rbo일때는 sort join 을 많이 사용 했지만, cbo일때는 hash를 많이 사용한다.)

sort merge join은 all_rows 상황에 최적화 가능하고, 정렬 작업의 부담이 클수록 성능이 저하 된다.


항상 생각해야할 것은 메모리를 사용해서 I/O가 발생한다는 것은 디스크로 내려갔을때 엄청난 부하가 온다는 것을 생각해야 한다.


* nested join 시 11g에서는 테이블간의 관계를 생각하면 된다. 누가 1의 집합인지를 생각하면 된다. 중복값을 누가 가지고 있고 누가 가지고 있지 않은지... 1을 먼저 수행하는 것이 I/O 성능이 더 좋다.
* hash join 시 테이블의 사이즈가 적은 것을 먼저 읽어야 성능이 좋다.


*outer join
아우터 조인을 수행 할 때는 데이터를 가지고 있는 쪽을 무조건 먼저 읽는다. /*+ leading(e) */ 불가능 [dept, emp]
select * 
from dept d, emp e
where d.deptno = e.deptno(+)
	And ( e.sal > 2000 );
이렇게 하면 deptno 40이 안나옴.. null 이기 때문에.. where절의 수행 조건은 트루 펄스인데, 널은 그냥 널이다...!
이럴때는 (+)를 가지고 있는 쪽에 일반 조건을 사용할떄는 계속해서 (+)를 붙혀서 사용하셈
And e.sal (+) > 2000 ;

이때 안시 조인을 사용하면
select *
from dept D left outer join emp E
	on D.deptno = E.deptno
	and E.sal > 2000;
이렇게 웨어절을 사용하지말고 온절에 and를 붙혀서 하셈

* 서브쿼리 안에서 그룹핑을 수행하면 뷰테이블이 생성됨. (퍼포먼스가 올라감)


* star_transformation





## hint
튜닝을 할때는 너무나 세부적으로 hint를 사용하면 않된다. 
개발->운영 으로 넘어갔을때 데이터의 양이 틀려질수도 있는데 사용자가 지정한 힌트를 기반으로 돌아가면 오히려 퍼포먼스가 훨씬 떨어질 수도 있다.




#서브쿼리

##

서브쿼리를 사용할 수 있으면 조인보다는 서브쿼리를 택하라. 

IN과 EXISTS 
EXISTS는 세미 조인을 실행함. 
세미조인은 실제 그 데이터가 있는지 없는지 만으로만 체크함. ( EXISTS 연산 자체가 값의 존재 유무를 체크하는 것과 같음)


프롬절에 들어가는 서브쿼리는 [ 조인으로 풀수 있 ]
웨어절에 들어가는 서브쿼리는 [ 네스티드로 풀수 있 ]

